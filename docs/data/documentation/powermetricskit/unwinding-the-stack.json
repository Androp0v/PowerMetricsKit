{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/PowerMetricsKit\/documentation\/PowerMetricsKit\/Unwinding-the-stack"},"metadata":{"role":"article","title":"Deep Dive: Unwinding the stack","modules":[{"name":"PowerMetricsKit"}],"roleHeading":"Article"},"hierarchy":{"paths":[["doc:\/\/PowerMetricsKit\/documentation\/PowerMetricsKit"]]},"schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"kind":"article","abstract":[{"text":"Get to know how the code to obtain the backtraces for all the threads in the process works.","type":"text"}],"primaryContentSections":[{"content":[{"level":2,"anchor":"Overview","text":"Overview","type":"heading"},{"inlineContent":[{"text":"This feature only works on AArch64, although it should be trivial to implement in other platforms. The steps to unwind the stack are described below, and explain the inner workings of ","type":"text"},{"type":"codeVoice","code":"get_backtrace.c"},{"type":"text","text":" in the associated "},{"type":"codeVoice","code":"SampleThreads"},{"text":" library listed in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/PowerMetricsKit\/documentation\/PowerMetricsKit"},{"type":"text","text":"’s dependencies."}],"type":"paragraph"},{"text":"Retrieving the stack contents","anchor":"Retrieving-the-stack-contents","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"To retrieve the content of a thread, we must first suspend it, which is done by calling Mach’s "},{"code":"thread_suspend","type":"codeVoice"},{"type":"text","text":". Then, the state of the thread is acquired using "},{"code":"thread_get_state","type":"codeVoice"},{"text":", which also retrieves the contents of the registers:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"c","code":["thread_suspend(thread);","mach_msg_type_number_t state_count = ARM_THREAD_STATE64_COUNT;","arm_thread_state64_t thread_state;","kern_return_t thread_state_result = thread_get_state(","    thread,","    ARM_THREAD_STATE64,","    (thread_state_t) &thread_state,","    &state_count",");"]},{"inlineContent":[{"text":"Here, the call to ","type":"text"},{"code":"thread_get_state","type":"codeVoice"},{"type":"text","text":" places the fetched state of the thread into "},{"type":"codeVoice","code":"thread_state"},{"text":". ","type":"text"},{"type":"codeVoice","code":"ARM_THREAD_STATE64"},{"type":"text","text":" specifies the format of the thread state to fetch (in this case: the format for AArch64)."}],"type":"paragraph"},{"style":"warning","type":"aside","content":[{"inlineContent":[{"type":"text","text":"Suspending a thread before unwinding its stack is required to ensure the stack is not being modified at the same time we’re reading its contents. Care should be taken when suspending threads."}],"type":"paragraph"}],"name":"Warning"},{"type":"aside","content":[{"inlineContent":[{"type":"text","text":"On macOS\/iOS, "},{"type":"codeVoice","code":"dladdr"},{"type":"text","text":" uses mutexes internally, so it’s possible to deadlock the sampling process by having "},{"type":"codeVoice","code":"dladdr"},{"type":"text","text":" wait on a lock that is currently held by one of the suspended threads."}],"type":"paragraph"}],"style":"warning","name":"Warning"},{"type":"paragraph","inlineContent":[{"text":"Once the state of the target thread has been acquired, we now want to find the addresses of the symbols in the Mach-O binary file that make up the call stack. To do that, we start by reading the latest contents of ","type":"text"},{"type":"codeVoice","code":"fp"},{"text":" (the Frame Pointer). The Procedure Call Standard for the Arm 64-bit Architecture says:","type":"text"}]},{"style":"note","name":"Procedure Call Standard for the Arm 64-bit Architecture","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"Conforming code shall construct a linked list of stack-frames. Each frame shall link to the frame of its caller by means of a frame record of two 64-bit values on the stack (independent of the data model). The frame record for the innermost frame (belonging to the most recent routine invocation) shall be pointed to by the Frame Pointer register (FP). The lowest addressed double-word shall point to the previous frame record and the highest addressed double-word shall contain the value passed in LR on entry to the current function. If code uses the pointer signing extension to sign return addresses, the value in LR must be signed before storing it in the frame record. The end of the frame record chain is indicated by the address zero in the address for the previous frame. The location of the frame record within a stack frame is not specified.","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Thus, we can retrieve the frame pointer of the caller by dereferencing the address in the current frame pointer, and the address of "},{"type":"codeVoice","code":"lr"},{"type":"text","text":" (the Link Register) as the 64 bits (8 bytes) that follow the frame pointer:"}]},{"type":"codeListing","code":["kern_return_t result = task_memcpy(","    task,","    current_frame_pointer,","    0,","    &next_frame_pointer,","    sizeof(int64_t)",");","if (result != KERN_SUCCESS) {","    break;","}","next_frame_pointer = (next_frame_pointer & PAC_STRIPPING_BITMASK);","","\/\/ Get the caller address (Link Register, lr) knowing it's a 8-byte ","\/\/ offset from the frame pointer (fp).","uint64_t caller_address;","uint64_t caller_address_pointer = 8 + (current_frame_pointer & PAC_STRIPPING_BITMASK);","kern_return_t caller_retrieval_result = task_memcpy(","    task,","    caller_address_pointer,","    0,","    &caller_address,","    sizeof(void *)",");"],"syntax":"c"},{"inlineContent":[{"type":"text","text":"Which essentially allows us to walk back one step in the frame pointer linked list. Here "},{"type":"codeVoice","code":"task_memcpy"},{"text":" wraps around ","type":"text"},{"code":"vm_read_overwrite","type":"codeVoice"},{"text":" to safely attempt to copy the contents of a memory address (failing without crashing\/signaling if the address is protected), and ","type":"text"},{"type":"codeVoice","code":"PAC_STRIPPING_BITMASK"},{"text":" is a constant used to strip ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/security\/preparing_your_app_to_work_with_pointer_authentication?","isActive":true,"type":"reference"},{"type":"text","text":" (PACs) from the memory addresses."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"caller_address","type":"codeVoice"},{"type":"text","text":" will be saved and passed back to the Swift side of the package, where "},{"type":"codeVoice","code":"dladdr"},{"type":"text","text":" will be used to obtain symbol information."}]}],"kind":"content"}],"variants":[{"paths":["\/documentation\/powermetricskit\/unwinding-the-stack"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://PowerMetricsKit/documentation/PowerMetricsKit":{"title":"PowerMetricsKit","kind":"symbol","role":"collection","type":"topic","abstract":[{"type":"text","text":"A package to retrieve realtime information on CPU energy consumption using the CPU’s Closed Loop Performance Counters (CLPC) via "},{"code":"proc_pidinfo","type":"codeVoice"},{"text":".","type":"text"}],"identifier":"doc:\/\/PowerMetricsKit\/documentation\/PowerMetricsKit","url":"\/documentation\/powermetricskit"},"https://developer.apple.com/documentation/security/preparing_your_app_to_work_with_pointer_authentication?":{"titleInlineContent":[{"type":"text","text":"Pointer Authentication Codes"}],"identifier":"https:\/\/developer.apple.com\/documentation\/security\/preparing_your_app_to_work_with_pointer_authentication?","url":"https:\/\/developer.apple.com\/documentation\/security\/preparing_your_app_to_work_with_pointer_authentication?","title":"Pointer Authentication Codes","type":"link"}}}